The file 1_basic_testing.py contains:
# Testing Your Code
# There are many ways to test your code. In this tutorial, you’ll learn the techniques from the most basic steps and work towards advanced methods.

# Automated vs. Manual Testing
# The good news is, you’ve probably already created a test without realizing it. Remember when you ran your application and used it for the first time? 
# Did you check the features and experiment using them? That’s known as exploratory testing and is a form of manual testing.

# Exploratory testing is a form of testing that is done without a plan. In an exploratory test, you’re just exploring the application.

# To have a complete set of manual tests, all you need to do is make a list of all the features your application has, the different types 
# of input it can accept, and the expected results. Now, every time you make a change to your code, you need to go through every single item on that list and check it.

# That doesn’t sound like much fun, does it?

# This is where automated testing comes in. Automated testing is the execution of your test plan (the parts of your application you want to test, 
# the order in which you want to test them, and the expected responses) by a script instead of a human. Python already comes with a set of tools
#  and libraries to help you create automated tests for your application. We’ll explore those tools and libraries in this tutorial.

# Unit Tests vs. Integration Tests
# The world of testing has no shortage of terminology, and now that you know the difference between automated and manual testing, it’s time to go a level deeper.

# Think of how you might test the lights on a car. You would turn on the lights (known as the test step) and go outside the car or 
# ask a friend to check that the lights are on (known as the test assertion). Testing multiple components is known as integration testing.

# Think of all the things that need to work correctly in order for a simple task to give the right result. These components are like the parts to your 
# application, all of those classes, functions, and modules you’ve written.

# A major challenge with integration testing is when an integration test doesn’t give the right result. It’s very hard to diagnose the issue without being 
# able to isolate which part of the system is failing. If the lights didn’t turn on, then maybe the bulbs are broken. Is the battery dead? 
# What about the alternator? Is the car’s computer failing?

# If you have a fancy modern car, it will tell you when your light bulbs have gone. It does this using a form of unit test.

# A unit test is a smaller test, one that checks that a single component operates in the right way. A unit test helps you to isolate what is
# broken in your application and fix it faster.

# You have just seen two types of tests:

# An integration test checks that components in your application operate with each other.
# A unit test checks a small component in your application.
# You can write both integration tests and unit tests in Python. To write a unit test for the built-in function sum(), you would 
# check the output of sum() against a known output.

# For example, here’s how you check that the sum() of the numbers (1, 2, 3) equals 6:
assert sum([1, 2, 3]) == 6 , "Should be 6"
# This will not output anything on the REPL because the values are correct.

# statement again with the wrong values to see an AssertionError:

assert sum([1, 1, 1]) == 6, "Should be 6"

def test_sum():
     assert sum([1, 2, 3]) == 6, "Should be 6"

def test_sum_tuple():
    assert sum((1, 2, 2)) == 6, "Should be 6"

# When you execute test_sum_2.py, the script will give an error because the sum() of (1, 2, 2) is 5, not 6. 

if __name__ == "__main__":
     test_sum()
     test_sum_tuple()
     print("Everything passed")





The file 4_unterstanding_testoutput.py contains:

def sum(arg):
    total = 0
    for val in arg:
        total += val
    return total

# Understanding Test Output
# That was a very simple example where everything passes, so now you’re going to try a failing test and interpret the output.

# sum() should be able to accept other lists of numeric types, like fractions.

# At the top of the test.py file, add an import statement to import the Fraction type from the fractions module in the standard library:

# Now add a test with an assertion expecting the incorrect value, in this case expecting the sum of 1/4, 1/4, and 2/5 to be 1:

import unittest
from fractions import Fraction

class TestSum(unittest.TestCase):
    def test_list_int(self):
        """
        Test that it can sum a list of integers
        """
        data = [1, 2, 3]
        result = sum(data)
        self.assertEqual(result, 6)

    def test_list_fraction(self):
        """
        Test that it can sum a list of fractions
        """
        data = [Fraction(1, 4), Fraction(1, 4), Fraction(2, 5)]
        result = sum(data)
        self.assertEqual(result, 1)

if __name__ == '__main__':
    unittest.main()
# If you execute the tests again with python -m unittest test, you should see the following output:

# $ python -m unittest test
# F.
# ======================================================================
# FAIL: test_list_fraction (test.TestSum)
# ----------------------------------------------------------------------
# Traceback (most recent call last):
#   File "test.py", line 21, in test_list_fraction
#     self.assertEqual(result, 1)
# AssertionError: Fraction(9, 10) != 1

# ----------------------------------------------------------------------
# Ran 2 tests in 0.001s

# FAILED (failures=1)
# In the output, you’ll see the following information:

# The first line shows the execution results of all the tests, one failed (F) and one passed (.).

# The FAIL entry shows some details about the failed test:

# The test method name (test_list_fraction)
# The test module (test) and the test case (TestSum)
# A traceback to the failing line
# The details of the assertion with the expected result (1) and the actual result (Fraction(9, 10))
# Remember, you can add extra information to the test output by adding the -v flag to the python -m unittest command.

The file 5_test_exercise1.py contains:

The file run_tests.sh contains:
python3 1_*.py
python3 2_*.py
python3 3_*.py
python3 4_*.py
python3 5_*.py
python3 6_*.py
gcc 7_test.c
./a.out
rm ./a.out

The file 3_writing_first_test.py contains:
# Writing Your First Test
# Let’s bring together what you’ve learned so far and, instead of testing the built-in sum() function, 
# test a simple implementation of the same requirement.

# Create a new project folder and, inside that, create a new folder called my_sum. Inside my_sum, 
# create an empty file called __init__.py. Creating the __init__.py file means that the my_sum folder 
# can be imported as a module from the parent directory.

# Your project folder should look like this:

# project/
# │
# └── my_sum/
#     └── __init__.py
# Open up my_sum/__init__.py and create a new function called sum(), which takes an 
# iterable (a list, tuple, or set) and adds the values together:

def sum(arg):
    total = 0
    for val in arg:
        total += val
    return total
# This code example creates a variable called total, iterates over all the values in arg,
# and adds them to total. It then returns the result once the iterable has been exhausted.

# How to Structure a Simple Test
# Before you dive into writing tests, you’ll want to first make a couple of decisions:

# What do you want to test?
# Are you writing a unit test or an integration test?
# Then the structure of a test should loosely follow this workflow:

# Create your inputs
# Execute the code being tested, capturing the output
# Compare the output with an expected result
# For this application, you’re testing sum(). There are many behaviors in sum() you could check, such as:

#   Can it sum a list of whole numbers (integers)?
#   Can it sum a tuple or set?
#   Can it sum a list of floats?
#   What happens when you provide it with a bad value, such as a single integer or a string?
#   What happens when one of the values is negative?
#   The most simple test would be a list of integers. Create a file, test.py with the following Python code:

import unittest

class TestSum(unittest.TestCase):
    def test_list_int(self):
        """
        Test that it can sum a list of integers
        """
        data = [1, 2, 3]
        result = sum(data)
        self.assertEqual(result, 6)

if __name__ == '__main__':
    unittest.main()

# How to Write Assertions
# The last step of writing a test is to validate the output against a known response. 
# This is known as an assertion. There are some general best practices around how to write assertions:

# Make sure tests are repeatable and run your test multiple times to make sure it gives the same result every time
# Try and assert results that relate to your input data, such as checking that the result is the actual sum of values in the sum() example
# unittest comes with lots of methods to assert on the values, types, and existence of variables. Here are some of the most commonly used methods:

# Method	Equivalent to
# .assertEqual(a, b)	a == b
# .assertTrue(x)	bool(x) is True
# .assertFalse(x)	bool(x) is False
# .assertIs(a, b)	a is b
# .assertIsNone(x)	x is None
# .assertIn(a, b)	a in b
# .assertIsInstance(a, b)	isinstance(a, b)
# .assertIs(), .assertIsNone(), .assertIn(), and .assertIsInstance() all have opposite methods, named .assertIsNot(), and so forth.

# Side Effects
# When you’re writing tests, it’s often not as simple as looking at the return value of a function. Often, executing a piece of code 
# will alter other things in the environment, such as the attribute of a class, a file on the filesystem, or a value in a database. 
# These are known as side effects and are an important part of testing. Decide if the side effect is being tested before including 
# it in your list of assertions.

# If you find that the unit of code you want to test has lots of side effects, you might be breaking the Single Responsibility Principle. 
# Breaking the Single Responsibility Principle means the piece of code is doing too many things and would be better off being refactored. 
# Following the Single Responsibility Principle is a great way to design code that it is easy to write repeatable and simple unit tests 
# for, and ultimately, reliable applications.
# Run the tests:
#   $ python -m unittest test
# You can provide additional options to change the output. One of those is -v for verbose. Try that next:
#   $ python -m unittest -v test
# Instead of providing the name of a module containing tests, you can request an auto-discovery using the following:
# $ python -m unittest discover
# This will search the current directory for any files named test*.py and attempt to test them.


The file 7_test.c contains:
#include <stdio.h>

int main(){
    printf("hello world\n");
    return 1;
}
The file 6_test_exercise2.py contains:

The file 2_automated_testing.py contains:

# Writing tests in this way is okay for a simple check, but what if more than one fails? This is where test runners come in. 
# The test runner is a special application designed for running tests, checking the output, 
# and giving you tools for debugging and diagnosing tests and applications.

# Choosing a Test Runner
# There are many test runners available for Python. The one built into the Python standard library is called unittest. 
# In this tutorial, you will be using unittest test cases and the unittest test runner. 
# The principles of unittest are easily portable to other frameworks. The three most popular test runners are:

#   unittest
#   nose or nose2 [this is pure irony for out course]
#   pytest
#   Choosing the best test runner for your requirements and level of experience is important.

# unittest
# unittest has been built into the Python standard library since version 2.1. We will be using it

# unittest contains both a testing framework and a test runner. unittest has some important requirements for writing and executing tests.

# unittest requires that:

# You put your tests into classes as methods
# You use a series of special assertion methods in the unittest.TestCase class instead of the built-in assert statement
# To convert the earlier example to a unittest test case, you would have to:
#   Import unittest from the standard library
#   Create a class called TestSum that inherits from the TestCase class
#   Convert the test functions into methods by adding self as the first argument
#   Change the assertions to use the self.assertEqual() method on the TestCase class
#   Change the command-line entry point to call unittest.main()
#   Follow those steps by creating a new file test_sum_unittest.py with the following code:

import unittest

class TestSum(unittest.TestCase):

    def test_sum(self):
        self.assertEqual(sum([1, 2, 3]), 6, "Should be 6")

    def test_sum_tuple(self):
        self.assertEqual(sum((1, 2, 2)), 6, "Should be 6")

if __name__ == '__main__':
    unittest.main()



